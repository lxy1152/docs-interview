<!doctype html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">🌲 Spring | 面试知识点整理</title><meta data-react-helmet="true" property="og:url" content="https://interview.docs.lixiangyu.xyz/framework/spring/spring"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-Hans"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🌲 Spring | 面试知识点整理"><meta data-react-helmet="true" name="description" content="----"><meta data-react-helmet="true" property="og:description" content="----"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://interview.docs.lixiangyu.xyz/framework/spring/spring"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/framework/spring/spring" hreflang="zh-Hans"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/framework/spring/spring" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9d41a9de.css">
<link rel="preload" href="/assets/js/runtime~main.fc7b7e97.js" as="script">
<link rel="preload" href="/assets/js/main.0270bc98.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">面试知识点整理</b></a><a class="navbar__item navbar__link" href="/">主页</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link">其他内容</a><ul class="dropdown__menu"><li><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="dropdown__link"><span>个人博客<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/lxy1152/docs-interview" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_MM2z"><input placeholder="请输入要搜索的内容" aria-label="Search" class="navbar__search-input"><div class="loadingRing_s5VG searchBarLoadingRing_2jQk"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">简介</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">😉 Java 基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌈 Java 容器</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🐺 Java 并发</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌏 JVM</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">🌱 框架使用</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">🌸 Spring 全家桶</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/framework/spring/spring">🌲 Spring</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/framework/spring/spring-mvc">🌳 SpringMVC</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/framework/spring/springboot">🌴 SpringBoot</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/framework/spring/springcloud">🌵 SpringCloud</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">💮 MyBatis</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">🏵️ 通讯</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👊 MySQL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🤷‍♂️ Redis</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🎠 中间件</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👨‍👧‍👧 计算机网络</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🦸 操作系统</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🏭 设计思想</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">📚 面经</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">本页总览</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">🌲 Spring</h1></header><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-spring-框架？"></a>什么是 Spring 框架？<a class="hash-link" href="#什么是-spring-框架？" title="标题的直接链接">#</a></h2><p>Spring 是一个轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说的 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助开发人员进行开发。</p><p>Spring 框架的特点：</p><ul><li>轻量：Spring 是轻量的</li><li>控制反转：Spring 通过控制反转实现了解耦</li><li>面向切面的编程（AOP）：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li><li>容器：Spring 包含并管理应用中对象的生命周期和配置</li><li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li><li>事务管理：Spring 提供了一个持续的事务管理接口</li><li>异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的 unchecked 异常。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="spring-有哪些模块？"></a>Spring 有哪些模块？<a class="hash-link" href="#spring-有哪些模块？" title="标题的直接链接">#</a></h2><p><img src="https://i.loli.net/2021/07/31/7UEfnFxiscSywvQ.png" alt="Spring模块.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-ioc？"></a>什么是 IoC？<a class="hash-link" href="#什么是-ioc？" title="标题的直接链接">#</a></h2><p>IoC（Inverse of Control，控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由 Spring 来管理。IoC 在其他语言中也有应用，并非 Spring 特有。IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个 <code>Map</code>，其中存放的是各种对象。IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件或者注解，完全不用考虑对象是如何被创建出来的。Spring 早期版本一般是通过 XML 文件来配置 Bean，目前更为流行的是通过注解来进行配置。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-aop？"></a>什么是 AOP？<a class="hash-link" href="#什么是-aop？" title="标题的直接链接">#</a></h2><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP 是基于动态代理实现的，如果要代理的对象实现了某个接口，那么 Spring AOP 会使用 JDKProxy 去创建代理对象，而对于没有实现接口的对象，会使用 CGLib 做代理，如下图所示：</p><p><img src="https://i.loli.net/2021/07/31/fnhaAE5dxJw3pq6.png" alt="动态代理.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="spring-框架中使用的设计模式？"></a>Spring 框架中使用的设计模式？<a class="hash-link" href="#spring-框架中使用的设计模式？" title="标题的直接链接">#</a></h2><ul><li>工厂设计模式：Spring 使用工厂模式，通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 Bean</li><li>代理设计模式：Spring AOP 功能的实现</li><li>单例设计模式：Spring 中的 Bean 默认都是单例的</li><li>包装器设计模式：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库，这种模式可以根据客户的需求能够动态切换不同的数据源</li><li>观察者模式: Spring 事件驱动模型</li><li>适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式，Spring MVC 中也使用到了适配器模式适配 Controller</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="spring-bean"></a>Spring Bean<a class="hash-link" href="#spring-bean" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="component-和-bean-注解的区别？"></a>@Component 和 @Bean 注解的区别？<a class="hash-link" href="#component-和-bean-注解的区别？" title="标题的直接链接">#</a></h3><ul><li><p><strong>作用对象不同</strong>：<code>@Component</code> 注解作用于类，而 <code>@Bean</code> 注解作用于方法。</p></li><li><p><strong>含义不同</strong>：因为 <code>@Component</code> 注解是作用于类的，所以它通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中的（通过 <code>@ComponentScan</code> 注解定义要扫描的路径）。<code>@Bean</code> 注解作用于方法，它注明了某个方法会产生一个 Bean。</p></li><li><p><strong>@Bean 注解能力更强</strong>：如果需要引用第三方库中的类到 Spring 容器中，那么就只能通过 <code>@Bean</code> 注解来实现。</p></li></ul><p>下面为两种注解的代码示例：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// Bean 注解代码示例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyBean createMyBean() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new MyBean();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// Component 注解代码示例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyComponent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fields and functions</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowried</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    MyComponent myComponent;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fields and functions</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Bean 的装配</h5></div><div class="admonition-content"><p>一般使用 <code>@Autowired</code> 注解自动装配 Bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 Bean，除了上面提到的这两种注解以外，还可以使用以下的三个注解。这些注解没有功能上的扩展，只是为了语义清晰：</p><ul><li><code>@Repository</code>: 对应持久层，即 Dao 层，主要用于数据库相关操作</li><li><code>@Service</code>: 对应服务层，主要涉及一些复杂的业务逻辑，需要用到 Dao 层</li><li><code>@Controller</code>: 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</li></ul></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bean-的生命周期？"></a>Bean 的生命周期？<a class="hash-link" href="#bean-的生命周期？" title="标题的直接链接">#</a></h3><p><img src="https://i.loli.net/2021/07/31/VtnmjZBhIK6scJM.png" alt="Bean生命周期.jpg"></p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>@PostConstruct 和 @PreDestroy</h5></div><div class="admonition-content"><p><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解不是 Spring 提供的注解，而是 javax 包中提供的注解，Spring 支持使用这两个注解。</p></div></div><p>示例代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 以下内容为Bean的实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.beans.BeansException;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.beans.factory.*;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.context.ApplicationContext;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.context.ApplicationContextAware;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.context.EnvironmentAware;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.context.ResourceLoaderAware;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.core.env.Environment;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.core.env.PropertySource;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.core.io.ResourceLoader;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.stereotype.Component;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.web.context.support.StandardServletEnvironment;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.annotation.PostConstruct;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.annotation.PreDestroy;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 以下函数的调用顺序与函数编写顺序相同</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author lixiangyu</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component(&quot;MyBean&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyBean implements InitializingBean, DisposableBean, ApplicationContextAware, BeanFactoryAware,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        BeanClassLoaderAware, BeanNameAware, EnvironmentAware, ResourceLoaderAware {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取Bean名称</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param s 名称</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setBeanName(String s) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;bean name is: &quot; + s);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取类加载器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param classLoader 类加载器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setBeanClassLoader(ClassLoader classLoader) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;class loader: &quot; + classLoader);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取Bean Factory</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;set bean factory... &quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取运行时环境变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setEnvironment(Environment environment) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里是在获取nacos中的配置项并转为Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PropertySource&lt;?&gt; propertySource</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                = ((StandardServletEnvironment) environment).getPropertySources().get(&quot;demo.yaml|DEFAULT_GROUP|||192.168.4.185:8848|||||||&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, String&gt; obj = (Map&lt;String, String&gt;) propertySource.getSource();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(obj);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;set environment...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取资源加载器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setResourceLoader(ResourceLoader resourceLoader) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;set resource loader...&quot; + resourceLoader);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取上下文</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param applicationContext 上下文</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws BeansException beansException</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;set application context...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ------ Bean Post Processor begin -----------</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在这里会调用postProcessBeforeInitialization方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在类实例化并且设置完属性后调用</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostConstruct</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void postConstruct() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;postConstruct...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 初始化方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Exception 异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void afterPropertiesSet() throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;after properties set...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在这里会调用postProcessAfterInitialization方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ------ Bean Post Processor end ------------</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Bean销毁时执行的方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PreDestroy</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void preDestroy() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;pre destroy...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Bean销毁时执行的方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Exception 异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void destroy() throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;destroy...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 以下内容为后置处理器BeanPostProcessor的实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.beans.BeansException;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.beans.factory.config.BeanPostProcessor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.springframework.stereotype.Component;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyBeanPostProcessor implements BeanPostProcessor {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean instanceof MyBean) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;bean post process before init...  &quot; + bean + &quot; &quot; + beanName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean instanceof MyBean) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;bean post process after init...  &quot; + bean + &quot; &quot; + beanName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bean-的作用域有哪些？"></a>Bean 的作用域有哪些？<a class="hash-link" href="#bean-的作用域有哪些？" title="标题的直接链接">#</a></h3><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Singleton</td><td align="center">单例，Spring 中的 Bean 默认都是单例的。</td></tr><tr><td align="center">Prototype</td><td align="center">每次请求都会创建一个新的 Bean 实例。</td></tr><tr><td align="center">Request</td><td align="center">每个 HTTP 请求都会产生一个新的 Bean，这个 Bean 仅在当前 HTTP request 内有效。</td></tr><tr><td align="center">Session</td><td align="center">每个 HTTP 请求都会产生一个新的 Bean，这个 Bean 仅在当前 HTTP session 内有效。</td></tr><tr><td align="center">Global-Session</td><td align="center">全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件，它们基于 Portlet 容器，可以像 servlet 一样处理 HTTP 请求，但是与 servlet 不同的是每个 portlet 都有不同的会话。</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="常见的-bean-转换工具有哪些？"></a>常见的 Bean 转换工具有哪些？<a class="hash-link" href="#常见的-bean-转换工具有哪些？" title="标题的直接链接">#</a></h3><p>推荐使用 <code>MapStruct</code>（编译时生成接口的实现类），<code>ModelMapper</code>（反射）。或者使用 Spring 提供的 <code>BeanUtils</code> 类（可能会有问题）。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>不用使用 Apache 提供的 BeanUtils 类</h5></div><div class="admonition-content"><p>阿里编程规范不推荐使用 Apache 提供的 <code>BeanUtils</code> 类，因为存在性能问题（存在大量的校验和日志记录）。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="beanfactory-和-factorybean-有哪些区别？"></a>BeanFactory 和 FactoryBean 有哪些区别？<a class="hash-link" href="#beanfactory-和-factorybean-有哪些区别？" title="标题的直接链接">#</a></h3><p><code>BeanFactory</code> 是接口，是 Spring 给 IoC 容器定义的一套完整的规范。<code>BeanFactory</code> 的实现类包括：</p><ul><li><code>AbstractBeanFactory</code>：抽象 Bean 工厂，绝大部分的实现类都是继承于他</li><li><code>DefaultListableBeanFactory</code>：Spring 默认的工厂类</li><li><code>XmlBeanFactory</code>：早期使用 XML 文件配置时所使用的 Bean 工厂</li><li><code>AbstractXmlApplicationContext</code>：抽象应用容器上下文对象</li><li><code>ClassPathXmlApplicationContext</code>：XML 解析上下文对象</li></ul><p><code>FactoryBean</code> 是 Spring IoC 容器创建 Bean 的一种形式，融合了简单工厂设计模式与装饰器模式。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="spring-的三级缓存？"></a>Spring 的三级缓存？<a class="hash-link" href="#spring-的三级缓存？" title="标题的直接链接">#</a></h3><p>在代码中有时可能会出现循环依赖，循环依赖是指是指 A 对象需要 B 对象，B 对象又需要 A 对象。比如下面这样：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private B b;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public A(B b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.b = b;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class B {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private A a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public B(A a) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.a = a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>如果碰到这种情况，那么实例化时必然会陷入死循环，因此 Spring 使用三级缓存来解决循环依赖这一问题。</p><ul><li><code>Map&lt;String, Object&gt; singletonObjects</code>：第一级缓存，用来存放已经完全创建好的单例 Bean，映射关系为 <code>beanName -&gt; Bean</code> 实例。</li><li><code>Map&lt;String, Object&gt; earlySingletonObjects</code>：第二级缓存，用来存放半成品的 Bean，映射关系为 <code>beanName -&gt; Bean</code> 实例。</li><li><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>：第三级缓存，用来存放单例 Bean 的 <code>ObjectFactory</code>，映射关系为 <code>beanName -&gt; ObjectFactory</code> 实例。</li></ul><p>还是以上面的 A 和 B 两个类为例，对创建过程详细的描述一下：</p><ul><li>首先创建 A，此时三级缓存中都没有 A，将 A 扔到一个集合中，这个集合的名称叫做：<code>singletonsCurrentlyInCreation</code>，表示它们正处于创建状态</li><li>对 A 做实例化，并放到第三级缓存中</li><li>为 A 注入对象，发现需要 B</li><li>从三级缓存中查找 B，发现都没有 B，将 B 放到 <code>singletonsCurrentlyInCreation</code> 中</li><li>对 B 做实例化，并放到第三级缓存中</li><li>为 B 注入对象，发现需要 A</li><li>将 A 从第三级缓存移动到第二级缓存，并返回给 B 做填充，但此时 A 只是个半成品，它的属性还没有填充完</li><li>B 创建完毕，从第三级缓存移动到第一级缓存</li><li>将 B 返回给 A，A 将 B 填充，A 创建完成</li><li>判断最后创建好的 A 和 B 中填充的 A 是不是一个对象，如果不是则抛出异常</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="spring-事务"></a>Spring 事务<a class="hash-link" href="#spring-事务" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="管理事务的两种方式？"></a>管理事务的两种方式？<a class="hash-link" href="#管理事务的两种方式？" title="标题的直接链接">#</a></h3><ul><li>编程式事务，在代码中硬编码（不推荐使用）</li><li>声明式事务，在配置文件中配置（推荐使用），包括基于 XML 的声明式事务和基于注解的声明式事务</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="事务隔离级别有哪些？"></a>事务隔离级别有哪些？<a class="hash-link" href="#事务隔离级别有哪些？" title="标题的直接链接">#</a></h3><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">TransactionDefinition.ISOLATION_DEFAULT</td><td align="center">使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ。</td></tr><tr><td align="center">TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td><td align="center">最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读和不可重复读。</td></tr><tr><td align="center">TransactionDefinition.ISOLATION_READ_COMMITTED</td><td align="center">允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读仍有可能发生。</td></tr><tr><td align="center">TransactionDefinition.ISOLATION_REPEATABLE_READ</td><td align="center">对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</td></tr><tr><td align="center">TransactionDefinition.ISOLATION_SERIALIZABLE</td><td align="center">最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="事务的传播方式有哪几种？"></a>事务的传播方式有哪几种？<a class="hash-link" href="#事务的传播方式有哪几种？" title="标题的直接链接">#</a></h3><p>事务传播行为（Propagation Behavior）指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。例如：方法 A 调用方法 B 时，方法 B 是继续在调用者方法 A 的事务中运行，还是为自己开启一个新事务运行，这就是由方法 B 的事务传播行为决定的。</p><p>Spring 支持以下 7 种事务传播方式：</p><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">PROPAGATION_REQUIRED</td><td align="center">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</td></tr><tr><td align="center">PROPAGATION_SUPPORTS</td><td align="center">如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</td></tr><tr><td align="center">PROPAGATION_MANDATORY</td><td align="center">如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</td></tr><tr><td align="center">PROPAGATION_REQUIRES_NEW</td><td align="center">创建一个新的事务，如果当前存在事务，则把当前事务挂起</td></tr><tr><td align="center">PROPAGATION_NOT_SUPPORTED</td><td align="center">以非事务方式运行，如果当前存在事务，则把当前事务挂起</td></tr><tr><td align="center">PROPAGATION_NEVER</td><td align="center">以非事务方式运行，如果当前存在事务，则抛出异常</td></tr><tr><td align="center">PROPAGATION_NESTED</td><td align="center">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="哪些方法可以开启事务？"></a>哪些方法可以开启事务？<a class="hash-link" href="#哪些方法可以开启事务？" title="标题的直接链接">#</a></h3><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，可以在方法上再次使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会导致回滚。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么情况下会导致事务回滚？"></a>什么情况下会导致事务回滚？<a class="hash-link" href="#什么情况下会导致事务回滚？" title="标题的直接链接">#</a></h3><p>在 <code>@Transactional</code> 注解中如果不配置 <code>rollbackFor</code> 属性，那么事务只会在遇到 <code>RuntimeException</code> 的时候才会回滚，加上 <code>rollbackFor=Exception.class</code> 可以让事务在遇到非运行时异常时也回滚。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="在什么场景下会导致事务失效？"></a>在什么场景下会导致事务失效？<a class="hash-link" href="#在什么场景下会导致事务失效？" title="标题的直接链接">#</a></h3><ul><li>数据库引擎不支持事务，比如 MyISAM</li><li>使用 <code>@Transactional</code> 标注的类没有被 Spring 容器管理</li><li>方法的修饰符不是 <code>public</code></li><li>自调用问题</li><li>数据源没有配置事务管理器</li><li>事务传播级别为：<code>PROPAGATION_NOT_SUPPORTED</code></li><li>没有添加 <code>rollbackFor=Exception.class</code></li><li>使用 <code>try-catch</code> 语句对异常进行了捕获，但没有重新抛出运行时异常</li></ul><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>什么是自调用</h5></div><div class="admonition-content"><p>自调用是指在类 A 里面有方法 a 和方法 b， 在方法 b 上面添加了 <code>@Transactional</code> 注解，在方法 a 中调用方法 b， 方法 b 的事务是不会生效的。原因在于同一个类之中，方法互相调用导致切面无效，而不仅仅是事务。事务之所以无效，是因为 Spring 的事务是通过 AOP 实现的。</p></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"></div><div class="col lastUpdated_3DPF">最后更新于 <b><time datetime="2021-08-17T02:43:13.000Z">2021/8/17</time></b> </div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/jvm/gc"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">« 🌙 垃圾回收机制</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/framework/spring/spring-mvc"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">🌳 SpringMVC »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是-spring-框架？" class="table-of-contents__link">什么是 Spring 框架？</a></li><li><a href="#spring-有哪些模块？" class="table-of-contents__link">Spring 有哪些模块？</a></li><li><a href="#什么是-ioc？" class="table-of-contents__link">什么是 IoC？</a></li><li><a href="#什么是-aop？" class="table-of-contents__link">什么是 AOP？</a></li><li><a href="#spring-框架中使用的设计模式？" class="table-of-contents__link">Spring 框架中使用的设计模式？</a></li><li><a href="#spring-bean" class="table-of-contents__link">Spring Bean</a><ul><li><a href="#component-和-bean-注解的区别？" class="table-of-contents__link">@Component 和 @Bean 注解的区别？</a></li><li><a href="#bean-的生命周期？" class="table-of-contents__link">Bean 的生命周期？</a></li><li><a href="#bean-的作用域有哪些？" class="table-of-contents__link">Bean 的作用域有哪些？</a></li><li><a href="#常见的-bean-转换工具有哪些？" class="table-of-contents__link">常见的 Bean 转换工具有哪些？</a></li><li><a href="#beanfactory-和-factorybean-有哪些区别？" class="table-of-contents__link">BeanFactory 和 FactoryBean 有哪些区别？</a></li><li><a href="#spring-的三级缓存？" class="table-of-contents__link">Spring 的三级缓存？</a></li></ul></li><li><a href="#spring-事务" class="table-of-contents__link">Spring 事务</a><ul><li><a href="#管理事务的两种方式？" class="table-of-contents__link">管理事务的两种方式？</a></li><li><a href="#事务隔离级别有哪些？" class="table-of-contents__link">事务隔离级别有哪些？</a></li><li><a href="#事务的传播方式有哪几种？" class="table-of-contents__link">事务的传播方式有哪几种？</a></li><li><a href="#哪些方法可以开启事务？" class="table-of-contents__link">哪些方法可以开启事务？</a></li><li><a href="#什么情况下会导致事务回滚？" class="table-of-contents__link">什么情况下会导致事务回滚？</a></li><li><a href="#在什么场景下会导致事务失效？" class="table-of-contents__link">在什么场景下会导致事务失效？</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">其他内容</div><ul class="footer__items"><li class="footer__item"><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>个人博客<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Xiangyu Li. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.fc7b7e97.js"></script>
<script src="/assets/js/main.0270bc98.js"></script>
</body>
</html>