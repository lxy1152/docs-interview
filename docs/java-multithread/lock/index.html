<!doctype html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">🐒 锁 | 面试知识点整理</title><meta data-react-helmet="true" property="og:url" content="https://interview.docs.lixiangyu.xyz/java-multithread/lock"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-Hans"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🐒 锁 | 面试知识点整理"><meta data-react-helmet="true" name="description" content="----"><meta data-react-helmet="true" property="og:description" content="----"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://interview.docs.lixiangyu.xyz/java-multithread/lock"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/java-multithread/lock" hreflang="zh-Hans"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/java-multithread/lock" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9d41a9de.css">
<link rel="preload" href="/assets/js/runtime~main.fc7b7e97.js" as="script">
<link rel="preload" href="/assets/js/main.0270bc98.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">面试知识点整理</b></a><a class="navbar__item navbar__link" href="/">主页</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link">其他内容</a><ul class="dropdown__menu"><li><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="dropdown__link"><span>个人博客<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/lxy1152/docs-interview" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_MM2z"><input placeholder="请输入要搜索的内容" aria-label="Search" class="navbar__search-input"><div class="loadingRing_s5VG searchBarLoadingRing_2jQk"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">简介</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">😉 Java 基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌈 Java 容器</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">🐺 Java 并发</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/java-multithread/jmm">🙈 JMM</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/java-multithread/process-thread">🙉 进程和线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/java-multithread/thread-pool">🙊 线程池</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/java-multithread/juc">🐵 J.U.C</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/java-multithread/lock">🐒 锁</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/java-multithread/non-lock">🦍 无同步方案</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌏 JVM</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌱 框架使用</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👊 MySQL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🤷‍♂️ Redis</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🎠 中间件</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👨‍👧‍👧 计算机网络</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🦸 操作系统</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🏭 设计思想</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">📚 面经</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">本页总览</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">🐒 锁</h1></header><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是互斥同步？"></a>什么是互斥同步？<a class="hash-link" href="#什么是互斥同步？" title="标题的直接链接">#</a></h2><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁，下面会提到）。互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="介绍一下-synchronized-关键字？"></a>介绍一下 Synchronized 关键字？<a class="hash-link" href="#介绍一下-synchronized-关键字？" title="标题的直接链接">#</a></h2><p><code>synchronized</code> 关键字可用于：</p><ul><li>同步一个代码块</li><li>同步一个方法（可以为静态方法）</li><li>同步一个类</li></ul><p><code>synchronized</code> 可以保证可见性，因为：</p><ul><li>线程加锁前，会清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li></ul><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>synchronized 在字节码中的实现</h5></div><div class="admonition-content"><ul><li>同步代码块时使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置</li><li>同步方法时并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的是使用 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法</li></ul></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Mark Word</h5></div><div class="admonition-content"><p>在 JVM 中对象是分成三部分存在的：对象头（header）、实例数据（instance Data）、对齐填充（padding）。实例数据存放类的属性数据信息，包括父类的属性信息，如果是数组，那么实例部分还包括数组的长度，这部分内存按 4 字节对齐。对齐填充不是必须部分，由于虚拟机要求对象起始地址必须是 8 字节的整数倍，对齐填充仅仅是为了使字节对齐。</p><p>对象头是 <code>synchronized</code> 实现锁的基础，因为 <code>synchronized</code> 申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由 Mark Word 和 Class Metadata Address 组成的，其中 Mark Word 存储对象的哈希值、锁信息、分代年龄、GC 标志等信息，Class Metadata Address 是类型指针指向对象的类元数据，JVM 通过该指针确定该对象是哪个类的实例。</p><p>其中 Mark Word 的锁信息就体现了锁的状态：</p><ul><li>无锁</li><li>偏向锁：多数情况下，锁不仅不存在竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，见锁优化部分的第五点</li><li>轻量级锁：如果明显存在其他线程申请锁，那么偏向锁将很快升级为轻量级锁</li><li>重量级锁：指原始的 <code>synchronized</code> 的实现，其他线程试图获取锁时都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程</li></ul></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="介绍一下-reentrantlock-类？"></a>介绍一下 ReentrantLock 类？<a class="hash-link" href="#介绍一下-reentrantlock-类？" title="标题的直接链接">#</a></h2><p><code>ReentrantLock</code> 是 J.U.C 包中提供的锁。示例代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Lock lock = new ReentrantLock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.execute(Main::func);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.execute(Main::func);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void func() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 10; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.print(i + &quot; &quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="它们两个有什么区别？"></a>它们两个有什么区别？<a class="hash-link" href="#它们两个有什么区别？" title="标题的直接链接">#</a></h2><p>这个问题可以泛指为 <code>synchronized</code> 和 <code>Lock</code> 接口的区别。</p><ul><li>锁的实现：<code>synchronized</code> 是 JVM 实现，<code>ReentrantLock</code> 是 JDK 实现的</li><li>性能： Java 对 <code>synchronized</code> 进行了很多优化，例如自旋锁等，<code>synchronized</code> 与 <code>ReentrantLock</code> 的性能大致相同</li><li>等待可中断： 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 可中断，而 <code>synchronized</code> 不行</li><li>公平锁：<code>synchronized</code> 中的锁是非公平的，<code>ReentrantLock</code> 默认情况下也是非公平的，但是也可以是公平的</li><li>锁的绑定条件：一个 <code>ReentrantLock</code> 可以同时绑定多个 <code>Condition</code> 对象，所以它更为灵活</li></ul><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>锁的使用</h5></div><div class="admonition-content"><p>除非需要使用 <code>ReentrantLock</code> 的高级功能，否则优先使用 <code>synchronized</code>。这是因为 <code>synchronized</code> 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 <code>ReentrantLock</code> 不是所有的 JDK 版本都支持。并且使用 <code>synchronized</code> 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是非阻塞同步？"></a>什么是非阻塞同步？<a class="hash-link" href="#什么是非阻塞同步？" title="标题的直接链接">#</a></h2><p>与悲观策略不同，还可以使用一种基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步，即乐观锁。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-cas？"></a>什么是 CAS？<a class="hash-link" href="#什么是-cas？" title="标题的直接链接">#</a></h2><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Unsafe 类</h5></div><div class="admonition-content"><p>有关 CAS 的操作可以在 <code>Unsafe</code> 类中查看，CAS 在不能成功交换时会进行自旋。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cas-存在的问题？"></a>CAS 存在的问题？<a class="hash-link" href="#cas-存在的问题？" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="aba-问题"></a>ABA 问题<a class="hash-link" href="#aba-问题" title="标题的直接链接">#</a></h3><p>如果一个变量初次读取的时候是 A，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。J.U.C 包提供了一个带有标记的原子引用类 <code>AtomicStampedReference</code> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="自旋消耗资源"></a>自旋消耗资源<a class="hash-link" href="#自旋消耗资源" title="标题的直接链接">#</a></h3><p>CAS 如果长时间不成功，会给CPU带来非常大的执行开销，如果 JVM 能支持处理器提供的 <code>pause</code> 指令，那么效率会有一定的提升。<code>pause</code> 指令有两个作用：</p><ul><li>它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li><li>它可以避免在循环的时候因内存顺序冲突（Memory Order Violation）而引起 CPU 流水线被清空，从而提高 CPU 的实行效率</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多变量共享一致性问题"></a>多变量共享一致性问题<a class="hash-link" href="#多变量共享一致性问题" title="标题的直接链接">#</a></h3><p>CAS 操作是针对一个变量的，如果对多个变量操作：</p><ul><li>可以加锁</li><li>封装成对象类</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="介绍一下-atomicinteger-类？"></a>介绍一下 AtomicInteger 类？<a class="hash-link" href="#介绍一下-atomicinteger-类？" title="标题的直接链接">#</a></h2><p>J.U.C 包里面的整数原子类 <code>AtomicInteger</code> 的方法调用了 <code>Unsafe</code> 类的 CAS 操作来保证线程安全。示例代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">private static AtomicInteger value = new AtomicInteger();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int total = 1000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExecutorService executorService = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    CountDownLatch countDownLatch = new CountDownLatch(total);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; total; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.execute(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            value.incrementAndGet();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            countDownLatch.countDown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    executorService.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(value.get());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p><code>incrementAndGet()</code> 会调用 <code>Unsafe</code> 包中的 <code>getAndAddInt</code>，其中：</p><ul><li><code>var1</code> 为原子类对象</li><li><code>var2</code> 为该字段相对对象内存地址的偏移</li><li><code>var4</code> 为要增加的数值，这里为 1</li><li><code>var5</code> 为旧的预期值</li></ul><p>通过 <code>compareAndSwapInt</code> 进行比较并交换，如果失败会一直自旋。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public final int getAndAddInt(Object var1, long var2, int var4) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int var5;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        var5 = this.getIntVolatile(var1, var2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return var5;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="锁优化"></a>锁优化<a class="hash-link" href="#锁优化" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是自旋锁？"></a>什么是自旋锁？<a class="hash-link" href="#什么是自旋锁？" title="标题的直接链接">#</a></h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是锁消除？"></a>什么是锁消除？<a class="hash-link" href="#什么是锁消除？" title="标题的直接链接">#</a></h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是锁粗化？"></a>什么是锁粗化？<a class="hash-link" href="#什么是锁粗化？" title="标题的直接链接">#</a></h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到有这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部，减少加锁的次数。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是轻量级锁？"></a>什么是轻量级锁？<a class="hash-link" href="#什么是轻量级锁？" title="标题的直接链接">#</a></h3><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是偏向锁？"></a>什么是偏向锁？<a class="hash-link" href="#什么是偏向锁？" title="标题的直接链接">#</a></h3><p>偏向锁的思想是：偏向于第一个获取锁对象的线程，这个线程在之后获取该锁时就不再需要进行同步操作，甚至连 CAS 操作也不再需要。当锁对象第一次被线程获得的时候，进入偏向状态，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。但是只要有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时会撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="在-java-中怎么排查死锁？"></a>在 Java 中怎么排查死锁？<a class="hash-link" href="#在-java-中怎么排查死锁？" title="标题的直接链接">#</a></h2><p>首先模拟一下死锁：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(A::method, &quot;Thread A&quot;).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(B::method, &quot;Thread B&quot;).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class A {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized static void method() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Thread.currentThread().getName() + &quot;: method from A&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(3000);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            B.method();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class B {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized static void method() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Thread.currentThread().getName() + &quot;: method from B&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(3000);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            A.method();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>线程 A 首先调用了 A 类中的同步方法，休眠 3 秒再继续调用 B 类中的同步方法。但是 B 类中的同步方法已经被线程 B 所调用，而线程 B 正在等待调用线程 A 的同步方法，所以双方会死锁。执行代码后将只会得到：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Thread A: method from A</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Thread B: method from B</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>可以使用 <code>jstack -l &lt;pid&gt;</code> 命令查看线程信息：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;Thread A&quot; #11 prio=5 os_prio=0 tid=0x000000001e899800 nid=0x32c4 waiting for monitor entry [0x000000001f3af000]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   java.lang.Thread.State: BLOCKED (on object monitor)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        at xyz.lixiangyu.demo.B.method(Main.java:25)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        - waiting to lock &lt;0x000000076b61f5f0&gt; (a java.lang.Class for xyz.lixiangyu.demo.B)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        at xyz.lixiangyu.demo.A.method(Main.java:16)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        - locked &lt;0x000000076b3a45c0&gt; (a java.lang.Class for xyz.lixiangyu.demo.A)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        at xyz.lixiangyu.demo.Main$$Lambda$1/1174361318.run(Unknown Source)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        at java.lang.Thread.run(Thread.java:748)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Locked ownable synchronizers:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        - None</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div><p>另外在 <code>jstack</code> 命令的输出中可以看到 Java 已经分析到了出现了死锁：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Found one Java-level deadlock:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">=============================</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;Thread B&quot;:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  waiting to lock monitor 0x000000001c5025d8 (object 0x000000076b3a45c0, a java.lang.Class),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  which is held by &quot;Thread A&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;Thread A&quot;:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  waiting to lock monitor 0x000000001c4ffd48 (object 0x000000076b61f5f0, a java.lang.Class),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  which is held by &quot;Thread B&quot;</span></span></code></pre><button type="button" aria-label="复制代码到剪贴板" class="copyButton_Ue-o clean-btn">复制</button></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"></div><div class="col lastUpdated_3DPF">最后更新于 <b><time datetime="2021-08-17T02:43:13.000Z">2021/8/17</time></b> </div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/java-multithread/juc"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">« 🐵 J.U.C</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/java-multithread/non-lock"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">🦍 无同步方案 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是互斥同步？" class="table-of-contents__link">什么是互斥同步？</a></li><li><a href="#介绍一下-synchronized-关键字？" class="table-of-contents__link">介绍一下 Synchronized 关键字？</a></li><li><a href="#介绍一下-reentrantlock-类？" class="table-of-contents__link">介绍一下 ReentrantLock 类？</a></li><li><a href="#它们两个有什么区别？" class="table-of-contents__link">它们两个有什么区别？</a></li><li><a href="#什么是非阻塞同步？" class="table-of-contents__link">什么是非阻塞同步？</a></li><li><a href="#什么是-cas？" class="table-of-contents__link">什么是 CAS？</a></li><li><a href="#cas-存在的问题？" class="table-of-contents__link">CAS 存在的问题？</a><ul><li><a href="#aba-问题" class="table-of-contents__link">ABA 问题</a></li><li><a href="#自旋消耗资源" class="table-of-contents__link">自旋消耗资源</a></li><li><a href="#多变量共享一致性问题" class="table-of-contents__link">多变量共享一致性问题</a></li></ul></li><li><a href="#介绍一下-atomicinteger-类？" class="table-of-contents__link">介绍一下 AtomicInteger 类？</a></li><li><a href="#锁优化" class="table-of-contents__link">锁优化</a><ul><li><a href="#什么是自旋锁？" class="table-of-contents__link">什么是自旋锁？</a></li><li><a href="#什么是锁消除？" class="table-of-contents__link">什么是锁消除？</a></li><li><a href="#什么是锁粗化？" class="table-of-contents__link">什么是锁粗化？</a></li><li><a href="#什么是轻量级锁？" class="table-of-contents__link">什么是轻量级锁？</a></li><li><a href="#什么是偏向锁？" class="table-of-contents__link">什么是偏向锁？</a></li></ul></li><li><a href="#在-java-中怎么排查死锁？" class="table-of-contents__link">在 Java 中怎么排查死锁？</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">其他内容</div><ul class="footer__items"><li class="footer__item"><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>个人博客<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Xiangyu Li. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.fc7b7e97.js"></script>
<script src="/assets/js/main.0270bc98.js"></script>
</body>
</html>