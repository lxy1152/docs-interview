<!doctype html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">🧝‍♂️ 进程与线程 | 面试知识点整理</title><meta data-react-helmet="true" property="og:url" content="https://interview.docs.lixiangyu.xyz/os/process-thread"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-Hans"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🧝‍♂️ 进程与线程 | 面试知识点整理"><meta data-react-helmet="true" name="description" content="----"><meta data-react-helmet="true" property="og:description" content="----"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://interview.docs.lixiangyu.xyz/os/process-thread"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/os/process-thread" hreflang="zh-Hans"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/os/process-thread" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9d41a9de.css">
<link rel="preload" href="/assets/js/runtime~main.fc7b7e97.js" as="script">
<link rel="preload" href="/assets/js/main.0270bc98.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">面试知识点整理</b></a><a class="navbar__item navbar__link" href="/">主页</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link">其他内容</a><ul class="dropdown__menu"><li><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="dropdown__link"><span>个人博客<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/lxy1152/docs-interview" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_MM2z"><input placeholder="请输入要搜索的内容" aria-label="Search" class="navbar__search-input"><div class="loadingRing_s5VG searchBarLoadingRing_2jQk"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">简介</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">😉 Java 基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌈 Java 容器</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🐺 Java 并发</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌏 JVM</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌱 框架使用</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👊 MySQL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🤷‍♂️ Redis</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🎠 中间件</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👨‍👧‍👧 计算机网络</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">🦸 操作系统</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/memory">🧙‍♂️ 内存管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/cpu-cache">🧚 CPU 缓存一致性</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/os/process-thread">🧝‍♂️ 进程与线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/lock">🧟 锁</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/io">🧛‍♂️ I/O</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🏭 设计思想</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">📚 面经</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">本页总览</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">🧝‍♂️ 进程与线程</h1></header><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程"></a>进程<a class="hash-link" href="#进程" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="并发和并行的区别？"></a>并发和并行的区别？<a class="hash-link" href="#并发和并行的区别？" title="标题的直接链接">#</a></h3><ul><li>并发：能够处理多个任务，但不一定同时</li><li>并行：能够处理多个任务，并且能够同时执行（只要速度足够快，看起来就像是在同时执行）</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程有哪几个状态？"></a>进程有哪几个状态？<a class="hash-link" href="#进程有哪几个状态？" title="标题的直接链接">#</a></h3><p><img src="https://i.loli.net/2021/08/01/Sdlb9XfRaGqYLUm.png" alt="进程状态1.png"></p><p>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，非常浪费空间。所以在使用虚拟内存管理的操作系统中，通常会把处于阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候再从硬盘换入到物理内存。通过挂起状态来描述这种行为。</p><p>挂起状态又分为：</p><ul><li>阻塞挂起：进程在外存（硬盘）并等待某个事件的出现</li><li>就绪挂起：进程在外存（硬盘），但只要进入内存，那么立刻就会运行（比如通过 Ctrl+Z 挂起进程）</li></ul><p><img src="https://i.loli.net/2021/08/01/RPVBXA2zmdyJptn.png" alt="进程状态2.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是进程控制块？"></a>什么是进程控制块？<a class="hash-link" href="#什么是进程控制块？" title="标题的直接链接">#</a></h3><p>进程控制块（process control block，PCB）是操作系统用来描述进程的一种数据结构。一个进程必然会对应一个 PCB，如果进程结束了，那么 PCB 也会随之消失。一个 PCB 中会包含以下信息：</p><ul><li>进程描述信息<ul><li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务</li></ul></li><li>进程控制和管理信息<ul><li>进程当前状态：如 new、ready、running、waiting 或 blocked 等</li><li>进程优先级：进程抢占 CPU 时的优先级</li></ul></li><li>资源分配清单<ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息</li></ul></li><li>CPU 相关信息<ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是进程的上下文切换？"></a>什么是进程的上下文切换？<a class="hash-link" href="#什么是进程的上下文切换？" title="标题的直接链接">#</a></h3><p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p><p><img src="https://i.loli.net/2021/08/01/sVzGlWwXuTQtIJB.png" alt="进程上下文切换.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="哪些情况会引发线程上下文切换？"></a>哪些情况会引发线程上下文切换？<a class="hash-link" href="#哪些情况会引发线程上下文切换？" title="标题的直接链接">#</a></h3><ul><li>时间片用完</li><li>所需资源（比如内存）不足</li><li>调用 <code>sleep</code> 主动挂起</li><li>有更高优先级的进程需要先执行</li><li>发生硬件中断</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="线程"></a>线程<a class="hash-link" href="#线程" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是线程？"></a>什么是线程？<a class="hash-link" href="#什么是线程？" title="标题的直接链接">#</a></h3><p>线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="线程与进程的比较？"></a>线程与进程的比较？<a class="hash-link" href="#线程与进程的比较？" title="标题的直接链接">#</a></h3><p>线程与进程的区别如下：</p><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系</li><li>线程能减少并发执行的时间和空间开销</li></ul><p>线程相比进程能减少开销，体现在：</p><ul><li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们</li><li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是线程的上下文切换？"></a>什么是线程的上下文切换？<a class="hash-link" href="#什么是线程的上下文切换？" title="标题的直接链接">#</a></h3><ul><li>当两个线程不是属于同一个进程时，切换的过程就跟进程上下文切换一样</li><li>当两个线程是属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="调度"></a>调度<a class="hash-link" href="#调度" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么情况下会发生调度？"></a>什么情况下会发生调度？<a class="hash-link" href="#什么情况下会发生调度？" title="标题的直接链接">#</a></h3><ul><li>从就绪态转变为运行态</li><li>从运行态转变为阻塞态</li><li>从运行态转变为结束态</li></ul><p>以上三种情况，操作系统都需要重新选择一个进程来执行，所以需要调度。调度算法大体上分为两类：</p><ul><li>非抢占式调度算法：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情</li><li>抢占式调度算法：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程，这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cpu-调度的基本原则？"></a>CPU 调度的基本原则？<a class="hash-link" href="#cpu-调度的基本原则？" title="标题的直接链接">#</a></h3><ul><li>CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率</li><li>系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量</li><li>周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好</li><li>等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意</li><li>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="有哪些调度算法？"></a>有哪些调度算法？<a class="hash-link" href="#有哪些调度算法？" title="标题的直接链接">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="先来先服务算法"></a>先来先服务算法<a class="hash-link" href="#先来先服务算法" title="标题的直接链接">#</a></h4><p>先来先服务（First Come First Severd, FCFS）算法是指每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，这将不利于短作业。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="最短作业优先调度算法"></a>最短作业优先调度算法<a class="hash-link" href="#最短作业优先调度算法" title="标题的直接链接">#</a></h4><p>最短作业优先（Shortest Job First, SJF）调度算法会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。但这种算法很明显对长作业不友好。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="高响应比优先调度算法"></a>高响应比优先调度算法<a class="hash-link" href="#高响应比优先调度算法" title="标题的直接链接">#</a></h4><p>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行，响应比优先级的计算公式：</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>优先权</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">优先权 = \frac{等待时间+要求服务时间}{要求服务时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord cjk_fallback">优</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">权</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">要</span><span class="mord cjk_fallback mtight">求</span><span class="mord cjk_fallback mtight">服</span><span class="mord cjk_fallback mtight">务</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">等</span><span class="mord cjk_fallback mtight">待</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">要</span><span class="mord cjk_fallback mtight">求</span><span class="mord cjk_fallback mtight">服</span><span class="mord cjk_fallback mtight">务</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="时间片轮转调度算法"></a>时间片轮转调度算法<a class="hash-link" href="#时间片轮转调度算法" title="标题的直接链接">#</a></h4><p>时间片轮转（Round Robin, RR）调度算法是给每个进程分配一个时间段，称为时间片（Quantum）。</p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="最高优先级调度算法"></a>最高优先级调度算法<a class="hash-link" href="#最高优先级调度算法" title="标题的直接链接">#</a></h4><p>时间片轮转算法做了个假设，即让所有的进程同等重要，大家的运行时间都一样。但是对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。</p><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化</li><li>动态优先级：根据进程的动态变化调整优先级，比如进程运的行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多级反馈队列调度算法"></a>多级反馈队列调度算法<a class="hash-link" href="#多级反馈队列调度算法" title="标题的直接链接">#</a></h4><p>多级反馈队列（Multilevel Feedback Queue）调度算法是时间片轮转算法和最高优先级算法的综合和发展。</p><ul><li>多级表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短</li><li>反馈表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程间的通信方式"></a>进程间的通信方式<a class="hash-link" href="#进程间的通信方式" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="为什么要进行进程间通信？"></a>为什么要进行进程间通信？<a class="hash-link" href="#为什么要进行进程间通信？" title="标题的直接链接">#</a></h3><p>程序中经常需要多个进程同时工作，这些进程需要互相通信，这就需要进程间通信。进程间的通信方式包括：</p><ul><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>信号</li><li>Socket</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何通过管道实现进程间通信？"></a>如何通过管道实现进程间通信？<a class="hash-link" href="#如何通过管道实现进程间通信？" title="标题的直接链接">#</a></h3><p>在 Linux 中使用符号 <code>|</code> 就是使用了管道的功能。这种方式实际上是创建了一个匿名管道，它将前一个命令的的输出作为后一个命令的输入，比如：<code>ps auxf | grep mysql</code>。</p><p>还有一种方式可以创建一个命名管道，它通过 <code>mkfifo</code> 命令创建，比如：<code>mkfifo myPipeline</code>。管道这种通信方式效率低，不适合进程间频繁通信。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何通过消息队列实现进程间通信？"></a>如何通过消息队列实现进程间通信？<a class="hash-link" href="#如何通过消息队列实现进程间通信？" title="标题的直接链接">#</a></h3><p>对于管道存在的问题，可以使用消息队列进行解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>但这种方式有两个问题：</p><ul><li>通信不及时</li><li>传送的消息大小有限制</li></ul><p>由于进程是写入数据到内核的消息队列，所以发生从用户态到内核态的过程，读取数据同理，所以还存在状态切换的开销。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何通过共享内存实现进程间通信？"></a>如何通过共享内存实现进程间通信？<a class="hash-link" href="#如何通过共享内存实现进程间通信？" title="标题的直接链接">#</a></h3><p>共享内存就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，不需要再传来传去，大大提高了进程间通信的速度。</p><p><img src="https://i.loli.net/2021/08/01/Qa3BSfYgqyCoLMj.png" alt="共享内存.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何通过信号量实现进程间通信？"></a>如何通过信号量实现进程间通信？<a class="hash-link" href="#如何通过信号量实现进程间通信？" title="标题的直接链接">#</a></h3><p>通过共享内存进行通信的方式会带来新的问题：如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。为了防止多进程竞争共享资源，而造成的数据错乱，需要一种保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量就实现了这样一种保护机制。</p><p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>P 操作：这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待，如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行</li><li>V 操作：这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行，如果信号量 &gt; 0，则表明当前没有阻塞中的进程</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。在下面的例子中信号量被初始化为 1：</p><p><img src="https://i.loli.net/2021/08/01/sMUOdwgqEIDbPiN.png" alt="pv操作举例.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何通过信号实现进程间通信？"></a>如何通过信号实现进程间通信？<a class="hash-link" href="#如何通过信号实现进程间通信？" title="标题的直接链接">#</a></h3><p>上面说的几种方式都是常规状态下的工作模式。对于异常情况下的工作模式，需要用信号的方式来通知进程。</p><p>在 Linux 中为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义，通过 <code>kill -l</code> 命令可以查看所有的信号。</p><p>在终端中，通过键盘组合键也可以发送信号：</p><ul><li><code>Ctrl + C</code>：产生 <code>SIGINT</code> 信号，表示终止进程</li><li><code>Ctrl + Z</code>：产生 <code>SIGTSTP</code> 信号，表示挂起进程</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何通过-socket-实现进程间通信？"></a>如何通过 Socket 实现进程间通信？<a class="hash-link" href="#如何通过-socket-实现进程间通信？" title="标题的直接链接">#</a></h3><p>前面所说的的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。针对 TCP 协议的 Socket 编程模型：</p><p><img src="https://i.loli.net/2021/08/01/KDGJEiz2WpLjhcN.png" alt="TCP编程模型.png"></p><p>针对 UDP 协议的 Socket 编程：</p><p><img src="https://i.loli.net/2021/08/01/wT5Y1NzIUK92Xnt.png" alt="udp编程模型.png"></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。</p></div><footer class="row docusaurus-mt-lg"><div class="col"></div><div class="col lastUpdated_3DPF">最后更新于 <b><time datetime="2021-08-17T02:43:13.000Z">2021/8/17</time></b> </div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/os/cpu-cache"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">« 🧚 CPU 缓存一致性</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/os/lock"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">🧟 锁 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#进程" class="table-of-contents__link">进程</a><ul><li><a href="#并发和并行的区别？" class="table-of-contents__link">并发和并行的区别？</a></li><li><a href="#进程有哪几个状态？" class="table-of-contents__link">进程有哪几个状态？</a></li><li><a href="#什么是进程控制块？" class="table-of-contents__link">什么是进程控制块？</a></li><li><a href="#什么是进程的上下文切换？" class="table-of-contents__link">什么是进程的上下文切换？</a></li><li><a href="#哪些情况会引发线程上下文切换？" class="table-of-contents__link">哪些情况会引发线程上下文切换？</a></li></ul></li><li><a href="#线程" class="table-of-contents__link">线程</a><ul><li><a href="#什么是线程？" class="table-of-contents__link">什么是线程？</a></li><li><a href="#线程与进程的比较？" class="table-of-contents__link">线程与进程的比较？</a></li><li><a href="#什么是线程的上下文切换？" class="table-of-contents__link">什么是线程的上下文切换？</a></li></ul></li><li><a href="#调度" class="table-of-contents__link">调度</a><ul><li><a href="#什么情况下会发生调度？" class="table-of-contents__link">什么情况下会发生调度？</a></li><li><a href="#cpu-调度的基本原则？" class="table-of-contents__link">CPU 调度的基本原则？</a></li><li><a href="#有哪些调度算法？" class="table-of-contents__link">有哪些调度算法？</a></li></ul></li><li><a href="#进程间的通信方式" class="table-of-contents__link">进程间的通信方式</a><ul><li><a href="#为什么要进行进程间通信？" class="table-of-contents__link">为什么要进行进程间通信？</a></li><li><a href="#如何通过管道实现进程间通信？" class="table-of-contents__link">如何通过管道实现进程间通信？</a></li><li><a href="#如何通过消息队列实现进程间通信？" class="table-of-contents__link">如何通过消息队列实现进程间通信？</a></li><li><a href="#如何通过共享内存实现进程间通信？" class="table-of-contents__link">如何通过共享内存实现进程间通信？</a></li><li><a href="#如何通过信号量实现进程间通信？" class="table-of-contents__link">如何通过信号量实现进程间通信？</a></li><li><a href="#如何通过信号实现进程间通信？" class="table-of-contents__link">如何通过信号实现进程间通信？</a></li><li><a href="#如何通过-socket-实现进程间通信？" class="table-of-contents__link">如何通过 Socket 实现进程间通信？</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">其他内容</div><ul class="footer__items"><li class="footer__item"><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>个人博客<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Xiangyu Li. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.fc7b7e97.js"></script>
<script src="/assets/js/main.0270bc98.js"></script>
</body>
</html>