<!doctype html>
<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">🧛‍♂️ I/O | 面试知识点整理</title><meta data-react-helmet="true" property="og:url" content="https://interview.docs.lixiangyu.xyz/os/io"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-Hans"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🧛‍♂️ I/O | 面试知识点整理"><meta data-react-helmet="true" name="description" content="----"><meta data-react-helmet="true" property="og:description" content="----"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://interview.docs.lixiangyu.xyz/os/io"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/os/io" hreflang="zh-Hans"><link data-react-helmet="true" rel="alternate" href="https://interview.docs.lixiangyu.xyz/os/io" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9d41a9de.css">
<link rel="preload" href="/assets/js/runtime~main.34b21a2d.js" as="script">
<link rel="preload" href="/assets/js/main.ce3f180b.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">面试知识点整理</b></a><a class="navbar__item navbar__link" href="/">主页</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link">其他内容</a><ul class="dropdown__menu"><li><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="dropdown__link"><span>个人博客<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/lxy1152/docs-interview" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_MM2z"><input placeholder="请输入要搜索的内容" aria-label="Search" class="navbar__search-input"><div class="loadingRing_s5VG searchBarLoadingRing_2jQk"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">简介</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">😉 Java 基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌈 Java 容器</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🐺 Java 并发</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌏 JVM</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🌱 框架使用</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👊 MySQL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🤷‍♂️ Redis</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🎠 中间件</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">👨‍👧‍👧 计算机网络</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">🦸 操作系统</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/memory">🧙‍♂️ 内存管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/cpu-cache">🧚 CPU 缓存一致性</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/process-thread">🧝‍♂️ 进程与线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/os/lock">🧟 锁</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/os/io">🧛‍♂️ I/O</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">🏭 设计思想</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">📚 面经</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">本页总览</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">🧛‍♂️ I/O</h1></header><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="io-多路复用"></a>I/O 多路复用<a class="hash-link" href="#io-多路复用" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="socket-模型的演进？"></a>Socket 模型的演进？<a class="hash-link" href="#socket-模型的演进？" title="标题的直接链接">#</a></h3><p>想要在不同的主机之间发送信息需要使用 Socket，一个最基本的模型如下图所示：</p><p><img src="https://i.loli.net/2021/08/01/YnOwgEstVAXGMrN.png" alt="socket模型.png"></p><p>但是这个模型只提供了一对一的服务，因为它使用的是阻塞 I/O，当服务端在还没处理完一个客户端的网络 I/O 时，或者读写操作发生阻塞时，其他客户端是无法与服务端连接的。为了使服务端能够对多个客户端提供服务，需要对上述模型进行改造，一种最简单的思路是：每有一个请求就创建一个线程为它提供服务。这种用多个进程来应付多个客户端的方式，在客户端数量比较少的时候还是可行的，但是当客户端数量很大，比如一万、十万时，肯定是扛不住的，因为每产生一个进程，必会占据一定的系统资源，除此之外还需要考虑进程间上下文切换的性能损耗。</p><p><img src="https://i.loli.net/2021/08/01/yhkdLPsqU8tb6nM.png" alt="socket模型1.png"></p><p>为了解决这个问题，可以引入线程池，通过使用线程池来避免线程的频繁创建和销毁。所谓的线程池，就是提前创建若干个线程，当有新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出已连接的 Socket 进程进行处理。</p><p><img src="https://i.loli.net/2021/08/01/CHlZTdQpyxcSJrz.png" alt="socket模型2.png"></p><p>上述的方案都可以解决，但都不是最好的方案。真正的解决方案是 I/O 多路复用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-io-多路复用？"></a>什么是 I/O 多路复用？<a class="hash-link" href="#什么是-io-多路复用？" title="标题的直接链接">#</a></h3><p>I/O 多路复用是指使用一个进程来维护多个 Socket，一个进程虽然在任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，也就是多路复用，这种思想很类似一个 CPU 并发多个进程。</p><p>I/O 多路复用主要涉及三个系统调用：select、poll、epoll。前两个基本相同，主要使用的是最后一个。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-select-和-poll？"></a>什么是 select 和 poll？<a class="hash-link" href="#什么是-select-和-poll？" title="标题的直接链接">#</a></h3><p>select 实现多路复用的方式是将已连接的 Socket 都放到一个文件描述符集合中，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生。检查的方式很粗暴，就是遍历，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方式找到可读或可写的 Socket，再对其进行处理。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 进行限制， 默认最大值为 1024，只能监听 0~1023 个文件描述符。</p><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，都是使用线性结构来存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，另外还需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发量的增长，性能的损耗会呈指数级增长。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-epoll？"></a>什么是 epoll？<a class="hash-link" href="#什么是-epoll？" title="标题的直接链接">#</a></h3><p>epoll 在两个方面进行了改造，很好解决了 select/poll 的问题。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="怎么保存所有待检测的文件描述字？"></a>怎么保存所有待检测的文件描述字？<a class="hash-link" href="#怎么保存所有待检测的文件描述字？" title="标题的直接链接">#</a></h4><p>epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里。红黑树是个高效的数据结构，增删查的时间复杂度是 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mclose">)</span></span></span></span></span>，避免了像 select/poll 操作一样每次都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="怎么知道存在-socket-需要处理？"></a>怎么知道存在 Socket 需要处理？<a class="hash-link" href="#怎么知道存在-socket-需要处理？" title="标题的直接链接">#</a></h4><p>epoll 使用事件驱动的机制，在内核里维护了一个链表来记录就绪事件，当某个 Socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 Socket 集合，大大提高了检测的效率。</p><p><img src="https://i.loli.net/2021/08/01/JcjvrEgOleKW1Ps.png" alt="epoll.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="epoll-的两种触发模式？"></a>epoll 的两种触发模式？<a class="hash-link" href="#epoll-的两种触发模式？" title="标题的直接链接">#</a></h3><ul><li><p>边缘触发模式：当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，因此程序要保证一次性将内核缓冲区的数据读取完，通常和非阻塞 I/O 搭配使用</p></li><li><p>水平触发模式：当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</p></li><li><p>对于 select 和 poll，它们只提供了水平触发模式，epoll 默认也是水平触发方式，但也可以配置为边缘触发模式。</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reactor-模型"></a>Reactor 模型<a class="hash-link" href="#reactor-模型" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-reactor？"></a>什么是 Reactor？<a class="hash-link" href="#什么是-reactor？" title="标题的直接链接">#</a></h3><p>Reactor 指的是对事件的反应，也就是说来了一个事件，Reactor 就有相对应的响应。事实上，Reactor 模式也叫 Dispatcher 模式，即收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。</p><p>Reactor 模式主要有以下四种实现方案：</p><ul><li>单 Reactor 单进程 / 线程</li><li>单 Reactor 多进程 / 线程</li><li>多 Reactor 单进程 / 线程</li><li>多 Reactor 多进程 / 线程</li></ul><p>其中，多 Reactor 单进程 / 线程的实现方案相比单 Reactor 单进程 / 线程的方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。主要介绍一下另外三种方案。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="介绍一下单-reactor-单进程线程模型？"></a>介绍一下单 Reactor 单进程/线程模型？<a class="hash-link" href="#介绍一下单-reactor-单进程线程模型？" title="标题的直接链接">#</a></h3><p><img src="https://i.loli.net/2021/08/01/3ZNEiHUuoLj7gnK.png" alt="reactor1.png"></p><p>这种方案存在两个缺点：</p><ul><li>因为只有一个进程，所以无法充分利用 多核 CPU 的性能</li><li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就会造成响应的延迟</li></ul><p>因此，这种方案更适合于业务处理非常快速的场景。比如 Redis（Redis 的瓶颈不在 CPU，而是内存和网络 I/O）。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="介绍一下单-reactor-多进程线程模型？"></a>介绍一下单 Reactor 多进程/线程模型？<a class="hash-link" href="#介绍一下单-reactor-多进程线程模型？" title="标题的直接链接">#</a></h3><p><img src="https://i.loli.net/2021/08/01/A1cW5D4xuwqJoft.png" alt="reactor2.png"></p><p>单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的性能，既然引入多线程，那么自然就带来了多线程竞争资源的问题。同时因为只有一个 Reactor 对象承担所有事件的监听和响应，在面对瞬间高并发的场景时，容易成为性能瓶颈。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="介绍一下多-reactor-多进程线程模型？"></a>介绍一下多 Reactor 多进程/线程模型？<a class="hash-link" href="#介绍一下多-reactor-多进程线程模型？" title="标题的直接链接">#</a></h3><p><img src="https://i.loli.net/2021/08/01/7rWqT5QtOoCKNSZ.png" alt="reactor3.png"></p><p>多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：</p><ul><li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理</li><li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无需返回数据，直接就可以在子线程将处理结果发送给客户端</li></ul><p>使用这种方案的包括 Netty，Memcached，Nginx。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="proactor"></a>Proactor<a class="hash-link" href="#proactor" title="标题的直接链接">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是同步异步，阻塞非阻塞？"></a>什么是同步/异步，阻塞/非阻塞？<a class="hash-link" href="#什么是同步异步，阻塞非阻塞？" title="标题的直接链接">#</a></h3><p>阻塞是指当用户程序执行 read 的时候，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，即拷贝过程完成时，read 才会返回。所以阻塞等待的是内核数据准备好和数据从内核态拷贝到用户态这两个过程。</p><p><img src="https://i.loli.net/2021/08/01/kTFSnVzM8Av3wY9.png" alt="阻塞io.png"></p><p>非阻塞 I/O 的 read 请求在数据未准备好的情况下会立即返回，并会继续往下执行，此时应用程序不断轮询内核，直到数据准备好，read 调用才可以获取到结果。但是最后一次 read 调用，获取数据的过程，是一个同步的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。过程如下图：</p><p><img src="https://i.loli.net/2021/08/01/9jSit8LTUMm57PA.png" alt="非阻塞io.png"></p><p>异步 I/O 指的是内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。当一切处理完成后，由操作系统通知应用程序过来处理。</p><p><img src="https://i.loli.net/2021/08/01/y3VUMcO29xsPS5C.png" alt="异步io.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="什么是-proactor？"></a>什么是 Proactor？<a class="hash-link" href="#什么是-proactor？" title="标题的直接链接">#</a></h3><p>Reactor 是非阻塞同步网络模式，而 Proactor 是异步网络模式。流程图如下：</p><p><img src="https://i.loli.net/2021/08/01/8RxVgNHO5qJnXtp.png" alt="proactor.png"></p><p>可惜的是，在 Linux 下的异步 I/O 是不完善的，aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 Socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p><p>而 Windows 里实现了一套完整的支持 Socket 的异步编程接口，这套接口就是 IOCP，是由操作系统级别实现的异步 I/O，真正意义上实现了异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="和-reactor-的对比？"></a>和 Reactor 的对比？<a class="hash-link" href="#和-reactor-的对比？" title="标题的直接链接">#</a></h3><p>Reactor 可以理解为：来了事件操作系统通知应用进程，让应用进程来处理；而 Proactor 可以理解为：来了事件操作系统来处理，处理完再通知应用进程。这里的事件可以指：新连接、有数据可读、有数据可写的这些 I/O 事件。这里的处理指从驱动读取到内核以及从内核读取到用户空间。</p></div><footer class="row docusaurus-mt-lg"><div class="col"></div><div class="col lastUpdated_3DPF">最后更新于 <b><time datetime="2021-08-16T11:30:01.000Z">2021/8/16</time></b> </div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/os/lock"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">« 🧟 锁</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/thoughts/design-pattern"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">👨‍🔧 设计模式 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#io-多路复用" class="table-of-contents__link">I/O 多路复用</a><ul><li><a href="#socket-模型的演进？" class="table-of-contents__link">Socket 模型的演进？</a></li><li><a href="#什么是-io-多路复用？" class="table-of-contents__link">什么是 I/O 多路复用？</a></li><li><a href="#什么是-select-和-poll？" class="table-of-contents__link">什么是 select 和 poll？</a></li><li><a href="#什么是-epoll？" class="table-of-contents__link">什么是 epoll？</a></li><li><a href="#epoll-的两种触发模式？" class="table-of-contents__link">epoll 的两种触发模式？</a></li></ul></li><li><a href="#reactor-模型" class="table-of-contents__link">Reactor 模型</a><ul><li><a href="#什么是-reactor？" class="table-of-contents__link">什么是 Reactor？</a></li><li><a href="#介绍一下单-reactor-单进程线程模型？" class="table-of-contents__link">介绍一下单 Reactor 单进程/线程模型？</a></li><li><a href="#介绍一下单-reactor-多进程线程模型？" class="table-of-contents__link">介绍一下单 Reactor 多进程/线程模型？</a></li><li><a href="#介绍一下多-reactor-多进程线程模型？" class="table-of-contents__link">介绍一下多 Reactor 多进程/线程模型？</a></li></ul></li><li><a href="#proactor" class="table-of-contents__link">Proactor</a><ul><li><a href="#什么是同步异步，阻塞非阻塞？" class="table-of-contents__link">什么是同步/异步，阻塞/非阻塞？</a></li><li><a href="#什么是-proactor？" class="table-of-contents__link">什么是 Proactor？</a></li><li><a href="#和-reactor-的对比？" class="table-of-contents__link">和 Reactor 的对比？</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">其他内容</div><ul class="footer__items"><li class="footer__item"><a href="https://blog.lixiangyu.xyz" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>个人博客<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.34b21a2d.js"></script>
<script src="/assets/js/main.ce3f180b.js"></script>
</body>
</html>